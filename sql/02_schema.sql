CREATE SCHEMA app AUTHORIZATION CURRENT_USER;

CREATE TYPE app.order_status AS ENUM ('draft','confirmed','shipped','delivered','cancelled','refunded');
CREATE TYPE app.payment_method AS ENUM ('card','transfer','cash','paypal');

CREATE TABLE app.roles (
  role_id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  name TEXT NOT NULL UNIQUE
);

CREATE TABLE app.users (
  user_id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  email CITEXT NOT NULL UNIQUE,
  full_name TEXT NOT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE TABLE app.user_roles (
  user_id BIGINT NOT NULL REFERENCES app.users(user_id) ON DELETE CASCADE,
  role_id BIGINT NOT NULL REFERENCES app.roles(role_id) ON DELETE RESTRICT,
  assigned_at TIMESTAMPTZ NOT NULL DEFAULT now(),PRIMARY KEY (user_id, role_id)
);

CREATE TABLE app.customers (
  customer_id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  name TEXT NOT NULL,
  email CITEXT UNIQUE,
  phone TEXT,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE TABLE app.products (
  product_id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  sku TEXT NOT NULL UNIQUE,
  name TEXT NOT NULL,
  price NUMERIC(12,2) NOT NULL CHECK (price >= 0),
  active BOOLEAN NOT NULL DEFAULT true,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE TABLE app.inventory_locations (
  location_id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  code TEXT NOT NULL UNIQUE,name TEXT NOT NULL
);

CREATE TABLE app.inventory (
  inventory_id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  product_id BIGINT NOT NULL REFERENCES app.products(product_id) ON DELETE CASCADE,
  location_id BIGINT NOT NULL REFERENCES app.inventory_locations(location_id) ON DELETE RESTRICT,
  quantity INTEGER NOT NULL CHECK (quantity >= 0),UNIQUE (product_id, location_id)
);

CREATE TABLE app.orders (
  order_id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  customer_id BIGINT NOT NULL REFERENCES app.customers(customer_id) ON DELETE RESTRICT,
  status app.order_status NOT NULL DEFAULT 'draft',
  ordered_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE TABLE app.order_items (
  order_id BIGINT NOT NULL REFERENCES app.orders(order_id) ON DELETE CASCADE,
  line_no SMALLINT NOT NULL,product_id BIGINT NOT NULL REFERENCES app.products(product_id) ON DELETE RESTRICT,
  quantity INTEGER NOT NULL CHECK (quantity > 0),
  unit_price NUMERIC(12,2) NOT NULL CHECK (unit_price >= 0),
  PRIMARY KEY (order_id, line_no)
);

CREATE TABLE app.payments (
  payment_id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  order_id BIGINT NOT NULL REFERENCES app.orders(order_id) ON DELETE RESTRICT,
  method app.payment_method NOT NULL,
  amount NUMERIC(12,2) NOT NULL CHECK (amount > 0),
  paid_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE INDEX idx_user_roles_role ON app.user_roles(role_id);
CREATE INDEX idx_inventory_product ON app.inventory(product_id);
CREATE INDEX idx_inventory_location ON app.inventory(location_id);
CREATE INDEX idx_orders_customer ON app.orders(customer_id);
CREATE INDEX idx_orders_status_ordered_at ON app.orders(status, ordered_at);
CREATE INDEX idx_order_items_product ON app.order_items(product_id);
CREATE INDEX idx_payments_order ON app.payments(order_id);

CREATE VIEW app.v_order_summary AS SELECT 
  o.order_id,
  o.customer_id,
  o.status,
  o.ordered_at,
COALESCE(SUM(oi.quantity * oi.unit_price),0)::NUMERIC(14,2) AS subtotal,
COALESCE(SUM(oi.quantity * oi.unit_price),0)::NUMERIC(14,2) - COALESCE(SUM(p.amount),0)::NUMERIC(14,2) AS balance_due 
FROM app.orders o 
LEFT JOIN app.order_items oi ON oi.order_id = o.order_id 
LEFT JOIN app.payments p ON p.order_id = o.order_id 
GROUP BY 
  o.order_id, 
  o.customer_id, 
  o.status, 
  o.ordered_at;



CREATE OR REPLACE FUNCTION app.touch_updated_at() 
RETURNS TRIGGER LANGUAGE plpgsql AS 
$$BEGIN 
  NEW.updated_at := now(); 
  RETURN NEW; 
END$$;

CREATE TRIGGER trg_users_touch BEFORE UPDATE ON app.users 
FOR EACH ROW EXECUTE FUNCTION app.touch_updated_at();

CREATE TRIGGER trg_customers_touch BEFORE UPDATE ON app.customers 
FOR EACH ROW EXECUTE FUNCTION app.touch_updated_at();

CREATE TRIGGER trg_products_touch BEFORE UPDATE ON app.products 
FOR EACH ROW EXECUTE FUNCTION app.touch_updated_at();

CREATE TRIGGER trg_orders_touch BEFORE UPDATE ON app.orders 
FOR EACH ROW EXECUTE FUNCTION app.touch_updated_at();

